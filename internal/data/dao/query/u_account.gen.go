// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"github.com/china-xs/kratos-tpl/internal/data/dao/model"
	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"
)

func newAccount(db *gorm.DB) account {
	_account := account{}

	_account.accountDo.UseDB(db)
	_account.accountDo.UseModel(model.Account{})

	tableName := _account.accountDo.TableName()
	_account.ID = field.NewInt32(tableName, "id")
	_account.Name = field.NewString(tableName, "name")
	_account.Mobile = field.NewString(tableName, "mobile")
	_account.Password = field.NewString(tableName, "password")
	_account.Age = field.NewInt32(tableName, "age")
	_account.Sex = field.NewBool(tableName, "sex")
	_account.Type = field.NewBool(tableName, "type")
	_account.Status = field.NewBool(tableName, "status")
	_account.CreateAt = field.NewTime(tableName, "create_at")
	_account.UpdateAt = field.NewTime(tableName, "update_at")

	return _account
}

type account struct {
	accountDo

	ID       field.Int32
	Name     field.String
	Mobile   field.String
	Password field.String
	Age      field.Int32
	Sex      field.Bool
	Type     field.Bool
	Status   field.Bool
	CreateAt field.Time
	UpdateAt field.Time
}

func (a account) clone(db *gorm.DB) account {
	a.accountDo.ReplaceDB(db)
	return a
}

type accountDo struct{ gen.DO }

func (a accountDo) Debug() *accountDo {
	a.DO = *a.DO.Debug().(*gen.DO)
	return &a
}

func (a accountDo) WithContext(ctx context.Context) *accountDo {
	a.DO = *a.DO.WithContext(ctx).(*gen.DO)
	return &a
}

func (a accountDo) Clauses(conds ...clause.Expression) *accountDo {
	a.DO = *a.DO.Clauses(conds...).(*gen.DO)
	return &a
}

func (a accountDo) Not(conds ...gen.Condition) *accountDo {
	a.DO = *a.DO.Not(conds...).(*gen.DO)
	return &a
}

func (a accountDo) Or(conds ...gen.Condition) *accountDo {
	a.DO = *a.DO.Or(conds...).(*gen.DO)
	return &a
}

func (a accountDo) Select(conds ...field.Expr) *accountDo {
	a.DO = *a.DO.Select(conds...).(*gen.DO)
	return &a
}

func (a accountDo) Where(conds ...gen.Condition) *accountDo {
	a.DO = *a.DO.Where(conds...).(*gen.DO)
	return &a
}

func (a accountDo) Order(conds ...field.Expr) *accountDo {
	a.DO = *a.DO.Order(conds...).(*gen.DO)
	return &a
}

func (a accountDo) Distinct(cols ...field.Expr) *accountDo {
	a.DO = *a.DO.Distinct(cols...).(*gen.DO)
	return &a
}

func (a accountDo) Omit(cols ...field.Expr) *accountDo {
	a.DO = *a.DO.Omit(cols...).(*gen.DO)
	return &a
}

func (a accountDo) Join(table schema.Tabler, on ...field.Expr) *accountDo {
	a.DO = *a.DO.Join(table, on...).(*gen.DO)
	return &a
}

func (a accountDo) LeftJoin(table schema.Tabler, on ...field.Expr) *accountDo {
	a.DO = *a.DO.LeftJoin(table, on...).(*gen.DO)
	return &a
}

func (a accountDo) RightJoin(table schema.Tabler, on ...field.Expr) *accountDo {
	a.DO = *a.DO.RightJoin(table, on...).(*gen.DO)
	return &a
}

func (a accountDo) Group(col field.Expr) *accountDo {
	a.DO = *a.DO.Group(col).(*gen.DO)
	return &a
}

func (a accountDo) Having(conds ...gen.Condition) *accountDo {
	a.DO = *a.DO.Having(conds...).(*gen.DO)
	return &a
}

func (a accountDo) Limit(limit int) *accountDo {
	a.DO = *a.DO.Limit(limit).(*gen.DO)
	return &a
}

func (a accountDo) Offset(offset int) *accountDo {
	a.DO = *a.DO.Offset(offset).(*gen.DO)
	return &a
}

func (a accountDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *accountDo {
	a.DO = *a.DO.Scopes(funcs...).(*gen.DO)
	return &a
}

func (a accountDo) Unscoped() *accountDo {
	a.DO = *a.DO.Unscoped().(*gen.DO)
	return &a
}

func (a accountDo) Create(values ...*model.Account) error {
	if len(values) == 0 {
		return nil
	}
	return a.DO.Create(values)
}

func (a accountDo) CreateInBatches(values []*model.Account, batchSize int) error {
	return a.DO.CreateInBatches(values, batchSize)
}

func (a accountDo) Save(values ...*model.Account) error {
	if len(values) == 0 {
		return nil
	}
	return a.DO.Save(values)
}

func (a accountDo) First() (*model.Account, error) {
	if result, err := a.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.Account), nil
	}
}

func (a accountDo) Take() (*model.Account, error) {
	if result, err := a.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.Account), nil
	}
}

func (a accountDo) Last() (*model.Account, error) {
	if result, err := a.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.Account), nil
	}
}

func (a accountDo) Find() ([]*model.Account, error) {
	result, err := a.DO.Find()
	return result.([]*model.Account), err
}

func (a accountDo) FindInBatches(result []*model.Account, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return a.DO.FindInBatches(&result, batchSize, fc)
}

func (a accountDo) FindByPage(offset int, limit int) (result []*model.Account, count int64, err error) {
	count, err = a.Count()
	if err != nil {
		return
	}

	result, err = a.Offset(offset).Limit(limit).Find()
	return
}
