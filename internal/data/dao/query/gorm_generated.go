// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"database/sql"

	"git.dev.enbrands.com/scrm/bed/scrm/app/auth/internal/data/dao/model"
	"gorm.io/gorm"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"
)

type account struct {
	gen.DO

	ID       field.Int32
	Name     field.String
	Mobile   field.String
	Password field.String
	Age      field.Int32
	Sex      field.Int32
	Type     field.Int32
	Status   field.Int32
}

func NewAccount(db *gorm.DB) *account {
	_account := new(account)

	_account.UseDB(db)
	_account.UseModel(model.Account{})

	tableName := _account.TableName()
	_account.ID = field.NewInt32(tableName, "id")
	_account.Name = field.NewString(tableName, "name")
	_account.Mobile = field.NewString(tableName, "mobile")
	_account.Password = field.NewString(tableName, "password")
	_account.Age = field.NewInt32(tableName, "age")
	_account.Sex = field.NewInt32(tableName, "sex")
	_account.Type = field.NewInt32(tableName, "type")
	_account.Status = field.NewInt32(tableName, "status")

	return _account
}

func (a account) Debug() *account {
	a.DO = *a.DO.Debug().(*gen.DO)
	return &a
}

func (a account) Hints(hs ...gen.Hint) *account {
	a.DO = *a.DO.Hints(hs...).(*gen.DO)
	return &a
}

func (a account) Not(conds ...gen.Condition) *account {
	a.DO = *a.DO.Not(conds...).(*gen.DO)
	return &a
}

func (a account) Or(conds ...gen.Condition) *account {
	a.DO = *a.DO.Or(conds...).(*gen.DO)
	return &a
}

func (a account) Select(conds ...field.Expr) *account {
	a.DO = *a.DO.Select(conds...).(*gen.DO)
	return &a
}

func (a account) Where(conds ...gen.Condition) *account {
	a.DO = *a.DO.Where(conds...).(*gen.DO)
	return &a
}

func (a account) Order(conds ...field.Expr) *account {
	a.DO = *a.DO.Order(conds...).(*gen.DO)
	return &a
}

func (a account) Distinct(cols ...field.Expr) *account {
	a.DO = *a.DO.Distinct(cols...).(*gen.DO)
	return &a
}

func (a account) Omit(cols ...field.Expr) *account {
	a.DO = *a.DO.Omit(cols...).(*gen.DO)
	return &a
}

func (a account) Join(table schema.Tabler, on ...gen.Condition) *account {
	a.DO = *a.DO.Join(table, on...).(*gen.DO)
	return &a
}

func (a account) LeftJoin(table schema.Tabler, on ...gen.Condition) *account {
	a.DO = *a.DO.LeftJoin(table, on...).(*gen.DO)
	return &a
}

func (a account) RightJoin(table schema.Tabler, on ...gen.Condition) *account {
	a.DO = *a.DO.RightJoin(table, on...).(*gen.DO)
	return &a
}

func (a account) Group(col field.Expr) *account {
	a.DO = *a.DO.Group(col).(*gen.DO)
	return &a
}

func (a account) Having(conds ...gen.Condition) *account {
	a.DO = *a.DO.Having(conds...).(*gen.DO)
	return &a
}

func (a account) Limit(limit int) *account {
	a.DO = *a.DO.Limit(limit).(*gen.DO)
	return &a
}

func (a account) Offset(offset int) *account {
	a.DO = *a.DO.Offset(offset).(*gen.DO)
	return &a
}

func (a account) Scopes(funcs ...func(gen.Dao) gen.Dao) *account {
	a.DO = *a.DO.Scopes(funcs...).(*gen.DO)
	return &a
}

func (a account) Unscoped() *account {
	a.DO = *a.DO.Unscoped().(*gen.DO)
	return &a
}

func (a account) Create(values ...*model.Account) error {
	if len(values) == 0 {
		return nil
	}
	return a.DO.Create(values)
}

func (a account) CreateInBatches(values []*model.Account, batchSize int) error {
	return a.DO.CreateInBatches(values, batchSize)
}

func (a account) Save(values ...*model.Account) error {
	if len(values) == 0 {
		return nil
	}
	return a.DO.Save(values)
}

func (a account) First() (*model.Account, error) {
	if result, err := a.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.Account), nil
	}
}

func (a account) Take() (*model.Account, error) {
	if result, err := a.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.Account), nil
	}
}

func (a account) Last() (*model.Account, error) {
	if result, err := a.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.Account), nil
	}
}

func (a account) Find() ([]*model.Account, error) {
	result, err := a.DO.Find()
	return result.([]*model.Account), err
}

func (a account) FindInBatches(result []*model.Account, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return a.DO.FindInBatches(&result, batchSize, fc)
}

func (a account) FindByPage(offset int, limit int) (result []*model.Account, count int64, err error) {
	count, err = a.Count()
	if err != nil {
		return
	}

	result, err = a.Offset(offset).Limit(limit).Find()
	return
}

func (a account) Begin(opts ...*sql.TxOptions) *account {
	a.DO = *a.DO.Begin(opts...).(*gen.DO)
	return &a
}

func (a account) Commit() *account {
	a.DO = *a.DO.Commit().(*gen.DO)
	return &a
}

func (a account) RollBack() *account {
	a.DO = *a.DO.Commit().(*gen.DO)
	return &a
}

func (a account) SavePoint(name string) *account {
	a.DO = *a.DO.SavePoint(name).(*gen.DO)
	return &a
}

func (a account) RollBackTo(name string) *account {
	a.DO = *a.DO.RollBackTo(name).(*gen.DO)
	return &a
}

type Query struct {
	db *gorm.DB

	Account *account
}

func (q *Query) Transaction(fc func(db *Query) error, opts ...*sql.TxOptions) error {
	return q.db.Transaction(func(tx *gorm.DB) error { return fc(q.withTx(tx)) }, opts...)
}

func (q Query) Begin(opts ...*sql.TxOptions) *Query {
	q.db = q.db.Begin(opts...)
	return &q
}

func (q Query) Commit() *Query {
	q.db = q.db.Commit()
	return &q
}

func (q Query) Rollback() *Query {
	q.db = q.db.Rollback()
	return &q
}

func (q Query) SavePoint(name string) *Query {
	q.db = q.db.SavePoint(name)
	return &q
}

func (q Query) RollbackTo(name string) *Query {
	q.db = q.db.RollbackTo(name)
	return &q
}

func (q Query) withTx(tx *gorm.DB) *Query {
	q.db = tx
	return &q
}

func Use(db *gorm.DB) *Query {
	return &Query{
		db:      db,
		Account: NewAccount(db),
	}
}
